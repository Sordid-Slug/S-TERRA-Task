# Build:
Просто прописать Make

Я создал двусвязный список универсальным относительно зранимых типов данных, но само задание выполнял и проверял исключительно под integer, не смотря на наличие функции принта всего списка для double. 
Задание выполнял так: создал до создания потоков список, заполнил его, далее разделил на две части(иногда одинаковые, иногда почти одинаковые по размеру) и уже передавал в потоковую функцию первому и второму потоку. С помощью мьютексов обеспечил синхронизацию.

# Ответы на вопросы:
2) В текущей реализации пользы от мьютекса нет. Я его добавлял, чтобы не было коллизий, но так как я уже разделил список на два, гонки за данными не будет, поэтому использование мьютекса бессмысленно.
3) Учитываются только значащие нули, например, для числа 0000 1011 первые 4 нуля учитываться не будут.

# Ответы на вопросы v2.0:
1) Касательно моего комментария в функции потока: если вынести проверку за пределы мьютекса, то проблема опять появится, видимо, из-за того, что единовременно оба потока пытаются получить доступ к элементу, однако мне всё ещё непонятно, почему даже если в дебаггере выполняются условия для выхода, программа всё равно их игнорирует.
2) param_args->start хранит указатель на элемент, с которого начинается проход. Он нужен, чтобы не писать разные функции под каждый поток: в одном потоке он хранит в себе указатель на list->head, в другом - на list->tail
3) Не думаю, что в данной реализации возможно увеличить количество параллельного кода. В данном случае, как миниму, ограничивает проверка на выход из цикла, которая работает без перебоев только под мьютексом.

# Изменения:
1) Все ошибки теперь выводятся на русском языке в поток вывода ошибок stderr.
2) Список не делится на несколько, а обрабатывается как один
3) После каждой попытки выделить память выполняется проверка на её корректность
4) Теперь нет segmentation fault
5) Исправлена проверка на количество аргументов. Раньше проверка было на рандомное число, это было для отладки

# Изменения v2.0:
1) Под dblLinkedList теперь не выделяется динамическая память, и без неё всё хорошо работает
2) Perror заменён на printf в местах проверок на успешность выделения памяти и блокирования мьютекса, т.к. эти действия не устанавливают errno.
3) Убрана неиспользующаяся переменная
4) Добавлен .gitignore
5) Больше не вылетает ошибка сегментации, если вводить неверный размер списка
6) Исправлен текст ошибки при нулевом размере списка

# Требования:

1. Код должен быть написан на языке C и собираться под Linux.

2. Исходники должны быть выложены на github.com с публичным доступом.

# Задание:

Сформировать в памяти один двусвязный список, содержащий случайные значения, которые следует получить из генератора случайных чисел.

Программа должна принимать на вход количество элементов в двухсвязном списке.

Запустить два потока (threads).

Потоку №1: начиная с головы списка подсчитывать количество нулевых битов в значениях элементов и количество пройденных элементов, освобождать учтённый элемент сразу после учёта.

Потоку №2: начиная с хвоста списка подсчитывать количество единичных битов в значениях элементов и количество пройденных элементов, освобождать учтённый элемент сразу после учёта.

По окончании элементов списка вывести результаты подсчёта.

Обеспечить однократную обработку каждого элемента списка (каждый должен быть учтён, но только один раз, одним из потоков).

Очень желательно, чтобы в потоках работали не две разные функции, а одна, принимающая особенности работы через аргументы.

Желательно научиться отлаживать программу при помощи GDB (The GNU Project Debugger).
